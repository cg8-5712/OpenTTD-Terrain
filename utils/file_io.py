"""
文件输入输出工具
"""
import json
import numpy as np
from PIL import Image
from pathlib import Path
import struct


def save_heightmap(heightmap, filepath, format='png'):
    """保存高度图"""
    filepath = Path(filepath)
    
    # 确保目录存在
    filepath.parent.mkdir(parents=True, exist_ok=True)
    
    # 归一化高度数据
    height_normalized = (heightmap - np.min(heightmap)) / (np.max(heightmap) - np.min(heightmap) + 1e-8)
    
    if filepath.suffix.lower() == '.png':
        # 保存为16位PNG
        height_uint16 = (height_normalized * 65535).astype(np.uint16)
        img = Image.fromarray(height_uint16, mode='I;16')
        img.save(filepath)
        print(f"高度图已保存为PNG: {filepath}")
        
    elif filepath.suffix.lower() == '.tif' or filepath.suffix.lower() == '.tiff':
        # 保存为TIFF
        height_float32 = heightmap.astype(np.float32)
        
        # 使用Pillow保存
        height_normalized_uint8 = (height_normalized * 255).astype(np.uint8)
        img = Image.fromarray(height_normalized_uint8, mode='L')
        img.save(filepath)
        print(f"高度图已保存为TIFF: {filepath}")
        
    elif filepath.suffix.lower() == '.npy':
        # 保存为NumPy数组
        np.save(filepath, heightmap)
        print(f"高度图已保存为NumPy数组: {filepath}")
        
    elif filepath.suffix.lower() == '.raw':
        # 保存为RAW二进制文件
        height_float32 = heightmap.astype(np.float32)
        with open(filepath, 'wb') as f:
            f.write(height_float32.tobytes())
        print(f"高度图已保存为RAW二进制: {filepath}")
        
    else:
        # 默认保存为PNG
        new_path = filepath.with_suffix('.png')
        save_heightmap(heightmap, new_path)
        print(f"不支持的格式，已转换为PNG: {new_path}")


def load_parameters(filepath):
    """加载参数"""
    from core.terrain_params import TerrainParams
    
    try:
        with open(filepath, 'r', encoding='utf-8') as f:
            params_dict = json.load(f)
        
        # 处理size参数
        if 'size' in params_dict and isinstance(params_dict['size'], list):
            params_dict['size'] = tuple(params_dict['size'])
        
        return TerrainParams(**params_dict)
    except Exception as e:
        print(f"加载参数失败: {e}")
        return TerrainParams()


def save_parameters(params, filepath):
    """保存参数"""
    filepath = Path(filepath)
    filepath.parent.mkdir(parents=True, exist_ok=True)
    
    try:
        with open(filepath, 'w', encoding='utf-8') as f:
            json.dump(params.to_dict(), f, indent=2, default=str)
        print(f"参数已保存: {filepath}")
    except Exception as e:
        print(f"保存参数失败: {e}")


def save_mesh(heightmap, filepath, scale=1.0, max_faces=50000):
    """
    从高度图生成并保存3D网格
    支持OBJ, STL, PLY格式
    """
    filepath = Path(filepath)
    suffix = filepath.suffix.lower()
    
    # 限制网格面数（避免太大）
    height, width = heightmap.shape
    if height * width > max_faces * 2:
        # 降采样
        factor = int(np.sqrt((height * width) / max_faces))
        heightmap = heightmap[::factor, ::factor]
        height, width = heightmap.shape
    
    print(f"生成网格: {width}x{height} vertices, 格式: {suffix}")
    
    if suffix == '.obj':
        _save_obj_mesh(heightmap, filepath, scale)
    elif suffix == '.stl':
        _save_stl_mesh(heightmap, filepath, scale)
    elif suffix == '.ply':
        _save_ply_mesh(heightmap, filepath, scale)
    else:
        # 默认保存为OBJ
        new_path = filepath.with_suffix('.obj')
        _save_obj_mesh(heightmap, new_path, scale)
        print(f"不支持的格式，已转换为OBJ: {new_path}")


def _save_obj_mesh(heightmap, filepath, scale=1.0):
    """保存为OBJ格式"""
    height, width = heightmap.shape
    
    with open(filepath, 'w', encoding='utf-8') as f:
        # 写入头部信息
        f.write("# Terrain Mesh Generated by Terrain Generator\n")
        f.write(f"# Vertices: {width * height}, Faces: {(width-1) * (height-1) * 2}\n\n")
        
        # 写入顶点
        for y in range(height):
            for x in range(width):
                z = heightmap[y, x] * scale
                # 调整坐标使地形居中
                x_pos = (x - width/2) * scale
                y_pos = (y - height/2) * scale
                f.write(f"v {x_pos:.6f} {y_pos:.6f} {z:.6f}\n")
        
        # 写入纹理坐标（简化版）
        for y in range(height):
            for x in range(width):
                u = x / (width - 1) if width > 1 else 0
                v = y / (height - 1) if height > 1 else 0
                f.write(f"vt {u:.6f} {v:.6f}\n")
        
        f.write("\n")
        
        # 写入面
        for y in range(height - 1):
            for x in range(width - 1):
                # 计算顶点索引（1-based）
                v1 = y * width + x + 1
                v2 = y * width + x + 2
                v3 = (y + 1) * width + x + 1
                v4 = (y + 1) * width + x + 2
                
                # 两个三角形构成一个四边形
                f.write(f"f {v1}/{v1} {v2}/{v2} {v3}/{v3}\n")
                f.write(f"f {v2}/{v2} {v4}/{v4} {v3}/{v3}\n")
    
    print(f"OBJ网格已保存: {filepath}")


def _save_stl_mesh(heightmap, filepath, scale=1.0):
    """保存为STL格式（二进制）"""
    height, width = heightmap.shape
    
    with open(filepath, 'wb') as f:
        # STL头部（80字节）
        header = b"Terrain Mesh Generated by Terrain Generator" + b"\x00" * 40
        f.write(header[:80])
        
        # 三角形数量
        num_triangles = (width - 1) * (height - 1) * 2
        f.write(struct.pack('<I', num_triangles))
        
        # 写入三角形
        for y in range(height - 1):
            for x in range(width - 1):
                # 计算顶点坐标
                def get_vertex(ix, iy):
                    z = heightmap[iy, ix] * scale
                    x_pos = (ix - width/2) * scale
                    y_pos = (iy - height/2) * scale
                    return (x_pos, y_pos, z)
                
                v1 = get_vertex(x, y)
                v2 = get_vertex(x + 1, y)
                v3 = get_vertex(x, y + 1)
                v4 = get_vertex(x + 1, y + 1)
                
                # 计算法向量
                def calculate_normal(p1, p2, p3):
                    u = np.array(p2) - np.array(p1)
                    v = np.array(p3) - np.array(p1)
                    normal = np.cross(u, v)
                    norm = np.linalg.norm(normal)
                    if norm > 0:
                        normal = normal / norm
                    return normal
                
                # 第一个三角形
                normal = calculate_normal(v1, v2, v3)
                f.write(struct.pack('<3f', *normal))  # 法向量
                f.write(struct.pack('<3f', *v1))      # 顶点1
                f.write(struct.pack('<3f', *v2))      # 顶点2
                f.write(struct.pack('<3f', *v3))      # 顶点3
                f.write(struct.pack('<H', 0))         # 属性字节计数
                
                # 第二个三角形
                normal = calculate_normal(v2, v4, v3)
                f.write(struct.pack('<3f', *normal))  # 法向量
                f.write(struct.pack('<3f', *v2))      # 顶点1
                f.write(struct.pack('<3f', *v4))      # 顶点2
                f.write(struct.pack('<3f', *v3))      # 顶点3
                f.write(struct.pack('<H', 0))         # 属性字节计数
    
    print(f"STL网格已保存: {filepath}")


def _save_ply_mesh(heightmap, filepath, scale=1.0):
    """保存为PLY格式（ASCII）"""
    height, width = heightmap.shape
    num_vertices = width * height
    num_faces = (width - 1) * (height - 1) * 2
    
    with open(filepath, 'w', encoding='utf-8') as f:
        # PLY头部
        f.write("ply\n")
        f.write("format ascii 1.0\n")
        f.write(f"element vertex {num_vertices}\n")
        f.write("property float x\n")
        f.write("property float y\n")
        f.write("property float z\n")
        f.write(f"element face {num_faces}\n")
        f.write("property list uchar int vertex_index\n")
        f.write("end_header\n")
        
        # 写入顶点
        for y in range(height):
            for x in range(width):
                z = heightmap[y, x] * scale
                x_pos = (x - width/2) * scale
                y_pos = (y - height/2) * scale
                f.write(f"{x_pos:.6f} {y_pos:.6f} {z:.6f}\n")
        
        # 写入面
        for y in range(height - 1):
            for x in range(width - 1):
                # 计算顶点索引（0-based）
                v1 = y * width + x
                v2 = y * width + x + 1
                v3 = (y + 1) * width + x
                v4 = (y + 1) * width + x + 1
                
                # 两个三角形
                f.write(f"3 {v1} {v2} {v3}\n")
                f.write(f"3 {v2} {v4} {v3}\n")
    
    print(f"PLY网格已保存: {filepath}")


def export_heightmap_with_texture(heightmap, base_path):
    """导出高度图和纹理"""
    base_path = Path(base_path)
    
    # 保存高度图
    heightmap_path = base_path.with_suffix('.png')
    save_heightmap(heightmap, heightmap_path)
    
    # 生成并保存纹理
    try:
        from utils.image_utils import generate_texture
        texture = generate_texture(heightmap)
        texture_path = base_path.with_name(base_path.stem + '_texture.png')
        texture.save(texture_path)
        print(f"纹理已保存: {texture_path}")
    except ImportError:
        print("无法生成纹理：image_utils模块未找到")
    
    return heightmap_path


def load_heightmap(filepath):
    """加载高度图"""
    filepath = Path(filepath)
    
    if filepath.suffix.lower() == '.npy':
        return np.load(filepath)
    elif filepath.suffix.lower() == '.raw':
        # 需要知道尺寸
        print("加载RAW文件需要指定尺寸")
        return None
    else:
        # 尝试作为图像加载
        img = Image.open(filepath)
        if img.mode == 'I;16':
            # 16位灰度
            data = np.array(img).astype(np.float32) / 65535.0
        else:
            # 其他格式，转换为灰度
            img_gray = img.convert('L')
            data = np.array(img_gray).astype(np.float32) / 255.0
        
        return data


# 为兼容性创建别名
save_height_map = save_heightmap
load_parameter = load_parameters
save_parameter = save_parameters


if __name__ == "__main__":
    # 测试代码
    test_heightmap = np.random.rand(100, 100)
    
    # 测试保存
    save_heightmap(test_heightmap, "test_heightmap.png")
    save_mesh(test_heightmap, "test_mesh.obj")
    
    # 测试参数
    params = TerrainParams()
    save_parameters(params, "test_params.json")
    
    loaded_params = load_parameters("test_params.json")
    print("测试完成!")